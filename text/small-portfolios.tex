\documentclass[conference]{IEEEtran}

%\usepackage[style=ieee, backend=bibtex]{biblatex}
\usepackage[ruled,linesnumbered,vlined]{algorithm2e} % pseudo-code
\usepackage{amsmath} % mathematical symbols
\usepackage{amssymb} % mathematical symbols
\usepackage{enumitem} % nicely formatted enumerations
\usepackage{graphicx} % plots
\usepackage{subcaption} % figures with multiple sub-figures and sub-captions
\usepackage{hyperref} % links and URLs
%\addbibresource{references.bib}

\newtheorem{definition}{Definition}

\begin{document}

\title{Analysis of Optimal Small Portfolios}

\author{\IEEEauthorblockN{Jakob Bach}
\IEEEauthorblockA{\textit{KIT Department of Informatics} \\
\textit{Karlsruhe Institute of Technology}\\
Karlsruhe, Germany \\
jakob.bach@kit.edu}
\and
\IEEEauthorblockN{Markus Iser}
\IEEEauthorblockA{\textit{KIT Department of Informatics} \\
\textit{Karlsruhe Institute of Technology}\\
Karlsruhe, Germany \\
markus.iser@kit.edu}
}

\maketitle

\begin{abstract}
Successful approaches that tackle hard combinatorial problems such as propositional satisfiability are often in some sense mutually complementary in terms of their running time. 
Parallel portfolio approaches and instance-specific algorithm selection approaches take advantage of this. 
In this paper, we present a systematic analysis of solver portfolios using runtime measurements from the SAT~Competition~2020 as an example. 
We present and compare solutions for the calculation of theoretically optimal portfolios of limited size and compare them to the quality of the prediction models trained for them. 
\end{abstract}

\begin{IEEEkeywords}
Propositional Satisfiability, Solver Portfolios, Runtime Prediction Models
\end{IEEEkeywords}

\section{Introduction}
\label{sec:introduction}

\paragraph{Outline}

Section~\ref{sec:related-work} reviews related work.
Section~\ref{sec:approach} introduces the small-portfolio problem and multiple solution approaches for it.
Section~\ref{sec:experimental-design} describes our experimental design.
Section~\ref{sec:evaluation} presents experimental results.
Section~\ref{sec:conclusion} concludes.

\section{Related Work}
\label{sec:related-work}

\section{Approach}
\label{sec:approach}

First, we introduce the small-portfolio problem.
Next, we present multiple approaches to solve it.

\subsection{Small-Portfolio Problem}

\subsubsection{Given Data}
\label{sec:approach:problem:data}

\begin{align*}
	S &= \{s_1, \dots, s_n\} \tag*{Solvers}\\
	I &= \{i_1, \dots, i_m\} \tag*{Instances}\\
	r &: S \times I \rightarrow \mathbb{N} \cup \{\bot\} \tag*{Runtimes (censored)}\\
	T &\in \mathbb{N} \tag*{Timeout}\\
	r_T(s,i) &:= \begin{cases}
		2*T & \text{if }r(s,i) = \bot\\
		r(s,i) & \text{otherwise}
	\end{cases} \tag*{Penalized Runtimes}
\end{align*}

Let $S$ be a set of solvers and $I$ be a set of SAT instances.
Let $r(s,i)$ be the runtimes of the solvers on the instances.
If a solver encounters an error, e.g., runs out of memory, or takes longer than time $T$ on an instance, the runtime is set to $\bot$ first.
Next, we penalize these missing runtimes with the double timeout, i.e., we use a PAR2 score.
We use these penalized runtimes $r_T(s,i)$ to score the solvers.

\subsubsection{Target Function}
\label{sec:approach:problem:target}

\begin{align*}
	c_{T} &: 2^S \rightarrow \mathbb{N}\\
	c_{T}(P) &:= \begin{cases}
		|I|*2*T & \text{if }P=\emptyset\\
		\sum_{i \in I}{\min\{r_T(s,i) \mid s \in P\}} & \text{otherwise}
	\end{cases} \tag*{Portfolio Cost}
\end{align*}

The cost of a solver equals its penalized runtime, summed over all instances.
A portfolio $P \subseteq S$ is a set of solvers.
To compute the cost of a portfolio $c_{T}(P)$, we assume to have an oracle that always chooses the fastest solver for each instance.
This is the \emph{virtual-best solver} (VBS).

In reality, one may train a prediction model that recommends a solver for each instance.
Such a prediction model uses features of the SAT instances to make its recommendations.
Only if the prediction model always recommends the fastest solver out of $P$ for each instance, the portfolio has the same costs as the VBS for $P$.
Else, the costs are higher, i.e., $c_{T}(P)$ is a lower bound for the actual portfolio costs.
In the worst case, the prediction model always recommends the slowest solver out of $P$ for each instance.
This serves as an upper bound for actual portfolio costs and it the \emph{virtual worst solver} (VWS).

\subsubsection{Optimization Problem}

\begin{equation}
	\label{eq:small-portfolio-problem}
	\begin{aligned}
		\min_P \quad & c_{T}(P)\\
		s.t. \quad & |P| \leq k
	\end{aligned}
   \tag{Small-Portfolio Problem}
\end{equation}

The \ref{eq:small-portfolio-problem} is to find a portfolio with minimum costs that contains at most $k$ solvers.
For each solver out of $S$, one needs to decide whether it becomes part of the portfolio $P$ or not.

\subsection{Solution Approaches}
\label{sec:approach:solution}

\subsubsection{Exhaustive Search}

The simplest way to solve the \ref{eq:small-portfolio-problem} is by exhaustively searching all portfolios with at most $k$ solvers.
Due to the use of a VBS, adding a solver to the portfolio cannot increase costs.
Thus, it is sufficient to search over all portfolios with exactly $k$ solvers.
Still, there are $\binom{n}{k}$ possible portfolios to search.
This can become infeasible, given sufficiently large $n$ and $k \gg 1$ as well as $k \ll n$.

\subsubsection{Integer Programming}

The \ref{eq:small-portfolio-problem} is not linear due to the use of the $\min$ function.
However, one can make it an integer linear problem by introducing additional variables.
This allows to obtain an exact solution for the problem with a standard integer-programming solver.

\begin{equation}
	\label{eq:small-portfolio-integer-problem}
	\begin{aligned}
		\min_{x,y} \quad & \sum_{i \in I} \sum_{s \in S} r_T(s,i) * x_{s,i} \\
		s.t. \quad & \begin{aligned}
			\forall_{i\in I} \sum_{s \in S} x_{s,i} &= 1\\
			\forall_{s \in S} \sum_{i \in I} x_{s,i} &\leq |I| * y_s\\
			\sum_{s \in S} y_s &\leq k\\
			\forall_{i\in I} \forall_{s \in S}~x_{s,i} &\in \{0, 1\}\\
			\forall_{s \in S}~y_s &\in \{0,1\}
		\end{aligned}
	\end{aligned}
	\tag{Small-Portfolio Integer Problem}
\end{equation}

There are two sets of decision variables.
$x_{s,i}$ denotes whether solver $s$ is used for instance $i$.
$y_s$ denotes whether a solver is in the portfolio.
Besides the cardinality constraint on the number of solvers, there are two additional constraints.
First, exactly one solver is chosen for each instance.
Second, a solver can only be chosen for an instance if it is part of the portfolio.

\subsubsection{Beam Search}

Beam search is a greedy algorithm that finds portfolios in an iterative manner.
Algorithm~\ref{al:beam-search} describes the approach:

\begin{algorithm}[htb]
	\KwIn{Penalized runtimes $r_T(s,i)$, portfolio size $k$, beam width $w$}
	\KwOut{Portfolio $P$ with $|P|=k$}
	$\mathbb{P}^0$ $\leftarrow$ \{$\emptyset$\}\tcp*[r]{portfolios of size 0}
	\For{$i \leftarrow 1$ \KwTo $k$}{
		$\mathbb{P}^i \leftarrow \emptyset$\tcp*[r]{portfolios of size $i$}
		\ForEach{$P \in \mathbb{P}^{i-1}$}{
			\ForEach{$s \in S$}{
				\If{$s \notin P$}{
					$\mathbb{P}^i \leftarrow \mathbb{P}^i \cup \{ P \cup \{ s \} \}$\tcp*[r]{add new portfolio}
				}
			}
		}
		$\mathbb{P}^i \leftarrow$ sort($\mathbb{P}_i$, $r_T$)\tcp*[r]{sort portfolios by costs}
		$\mathbb{P}^i \leftarrow \{\mathbb{P}_j^i \in \mathbb{P}^i \mid j \leq w \}$\tcp*[r]{best $w$ portfolios of size $i$}
	}
	\Return $\underset{P \in \mathbb{P}^k}{\arg\min}~c_{T}(P)$\;
	\caption{Beam Search}
	\label{al:beam-search}
\end{algorithm}

The algorithm starts with an empty portfolio.
In each iteration, the algorithm creates all combinations of portfolios from the previous iteration and individual solvers which are not part of these portfolios.
I.e., the algorithm expands existing portfolios by adding single solvers.
Before going to the next iteration, only the $w$ portfolios with the lowest cost are retained.
The beam-width $w$ is an input parameter.
For $w=1$, only one portfolio remains at the end of each iteration.
For maximal $w$, all portfolios remain.

The algorithm is a heuristic that does not necessarily find the optimal solution to the \ref{eq:small-portfolio-problem}.
In return, its only needs to check $O(n \cdot w)$ portfolios per iteration, yielding a runtime advantage compared to exhaustive search.
Additionally, we can provide a bound for the costs of a portfolio found by beam search with $w=1$.
To this end, we use a result from \cite{nemhauser1978analysis} for greedy algorithms on non-negative monotone submodular set functions.
In the following, we show that a slightly transformed version of the objective function in the \ref{eq:small-portfolio-problem} fulfills the requirements for the bound.
We start with the following definitions~\cite{krause2014submodular}:

\begin{definition}[Submodular set function]
	A function $f : 2^V \rightarrow \mathbb{R}$ is submodular if for every $A, B \subseteq V$, $f(A \cap B) + f(A \cup B) \leq f(A) + f(B)$.
	\label{def:submodular}
\end{definition}

\begin{definition}[Monotone set function]
	A function $f : 2^V \rightarrow \mathbb{R}$ is monotone if for every $A \subseteq B \subseteq V$, $f(A) \leq f(B)$.
	\label{sef:monotone}
\end{definition}

Our cost function $c_{T}: 2^S \rightarrow \mathbb{N}$ is a set function, but it is non-increasing instead of non-decreasing (monotone).
Thus, we define the following transformed version:

\begin{align*}
	u_{T} &: 2^S \rightarrow \mathbb{N}\\
	u_{T}(P) &:= \begin{cases}
		0 & \text{if }P=\emptyset\\
		c_W - c_{T}(P) & \text{otherwise}
	\end{cases} \tag*{Portfolio Utility}
\end{align*}

with the cost of the virtual-worst solver defined as:

\begin{align*}
	c_W := \sum_{i \in I}{\max_{s \in S}{r_T(s,i)}} \tag*{Virtual Worst Solver}
\end{align*}

Our definition of portfolio utility is non-negative, as $c_{T}(P) \leq c_W$.
Additionally, $u_{T}(P)$ is monotone.
In general, for $A \subseteq B \subseteq \mathbb{R}$, it holds that $\min(A) \geq \min(B)$.
For $A \subseteq B \subseteq S$, we obtain $\sum_{i \in I}{\min_{s \in A}{r_T(s,i)}} \geq \sum_{i \in I}{\min_{s \in B}{r_T(s,i)}}$.
Thus, $c_{T}(A) \geq c_{T}(B)$ and therefore $u_{T}(A) \leq u_{T}(B)$. \hfill$\square$

Next, we show that $u_{T}(P)$ is submodular.
Let $A,B \subseteq S$, $A,B \neq \emptyset$ be two portfolios.
For our proof, we split the set of instances $I$ in two subsets.
$I_A := \{i \in I \mid \min_{s \in A}{r_T(s,i)} < \min_{s \in B}{r_T(s,i)} \}$ contains the instances where portfolio A is faster.
$I_B := I \setminus I_A$ contains the remaining instances.
We now show that Definition~\ref{def:submodular} holds:

%TODO Make width narrower and define multi-line format in a way that permits page breaks
\begin{align*}
	& u_{T}(A) + u_{T}(B) - u_{T}(A \cap B) - u_{T}(A \cup B)\\
	= & c_W - c_{T}(A) + c_W - c_{T}(B) - c_W + c_{T}(A \cap B) - c_W + c_{T}(A \cup B)\\
	= & - \sum_{i \in I}{\min_{s \in A}{r_T(s,i)}} - \sum_{i \in I}{\min_{s \in B}{r_T(s,i)}} + \sum_{i \in I}{\min_{s \in A \cap B}{r_T(s,i)}} + \sum_{i \in I}{\min_{s \in A \cup B}{r_T(s,i)}}\\
	= & - \sum_{i \in I_A}{\min_{s \in A}{r_T(s,i)}} - \sum_{i \in I_B}{\min_{s \in A}{r_T(s,i)}} - \sum_{i \in I_A}{\min_{s \in B}{r_T(s,i)}} - \sum_{i \in I_B}{\min_{s \in B}{r_T(s,i)}}\\
	& + \sum_{i \in I_A}{\min_{s \in A \cap B}{r_T(s,i)}} + \sum_{i \in I_B}{\min_{s \in A \cap B}{r_T(s,i)}} + \sum_{i \in I_A}{\min_{s \in A \cup B}{r_T(s,i)}} + \sum_{i \in I_B}{\min_{s \in A \cup B}{r_T(s,i)}}\\
	= & - \sum_{i \in I_B}{\min_{s \in A}{r_T(s,i)}} - \sum_{i \in I_A}{\min_{s \in B}{r_T(s,i)}} + \sum_{i \in I_A}{\min_{s \in A \cap B}{r_T(s,i)}} + \sum_{i \in I_B}{\min_{s \in A \cap B}{r_T(s,i)}}\\
	\geq & 0 \Leftrightarrow u_{T}(A \cap B) + u_{T}(A \cup B) \leq u_{T}(A) + u_{T}(B)
\end{align*}\hfill$\square$

We made use of the fact that $\sum_{i \in I_A}{\min_{s \in A}{r_T(s,i)}} = \sum_{i \in I_A}{\min_{s \in A \cup B}{r_T(s,i)}}$ and $\sum_{i \in I_B}{\min_{s \in B}{r_T(s,i)}} = \sum_{i \in I_B}{\min_{s \in A \cup B}{r_T(s,i)}}$.
Also, $\sum_{i \in I_A}{\min_{s \in A \cap B}{r_T(s,i)}} \geq \sum_{i \in I_A}{\min_{s \in B}{r_T(s,i)}}$ and $\sum_{i \in I_B}{\min_{s \in A \cap B}{r_T(s,i)}} \geq \sum_{i \in I_B}{\min_{s \in A}{r_T(s,i)}}$, since $A \subseteq A \cap B$ and $B \subseteq A \cap B$.
Note the we stated $A,B \neq \emptyset$.
However, in these cases, the inequality simply holds with equality.
E.g., let $B = \emptyset$:

\begin{align*}
	& u_{T}(A) + u_{T}(B) - u_{T}(A \cap B) - u_{T}(A \cup B)\\
	= & u_{T}(A) + u_{T}(\emptyset) - u_{T}(\emptyset) - u_{T}(A)\\
	= & 0
\end{align*}

Having shown that $u_{T}(P)$ is non-negative, monotone and submodular, we can give the following bound on a beam-search result $P_{beam}^k$ with $w=1$~\cite{nemhauser1978analysis, krause2014submodular}:

\begin{equation}
	u_{T}(P_{beam}^k) \geq (1 - \frac{1}{e}) * \max_{|P| \leq k}{u_{T}(P)}
\end{equation}

I.e., there is a lower bound on the utility of a portfolio found by beam search.
With a minor transformation, this is an upper bound on the cost of a portfolio found by beam search:

\begin{equation}
	c_{T}(P_{beam}^k) - c_W \leq (1 - \frac{1}{e}) * (\min_{|P| \leq k}{c_{T}(P)} - c_W)
\end{equation}

\section{Experimental Design}
\label{sec:experimental-design}

\subsection{Optimization Approaches}

We analyze the \ref{eq:small-portfolio-problem} for two definitions of runtime in the objective function:

\begin{itemize}
	\item \emph{PAR2}:
	The penalized runtimes as described in Section~\ref{sec:approach:problem:data}, with a penalty of $2*T$ for runtimes over the timeout $T$:
	\begin{align*}
		r_T(s,i) &:= \begin{cases}
			2*T & \text{if }r(s,i) = \bot\\
			r(s,i) & \text{otherwise}
		\end{cases}
	\end{align*}
	\item \emph{Solved}:
	A heavily discretized version of the runtimes, only stating whether a solver did not finish within $T$.
	\begin{align*}
		r_T(s,i) &:= \begin{cases}
			1 & \text{if }r(s,i) = \bot\\
			0 & \text{otherwise}
		\end{cases}
	\end{align*}
\end{itemize}

We employ the three solution approaches from Section~\ref{sec:approach:solution} to search for portfolios:
%TODO Use actual parameter values

\begin{itemize}
	\item \emph{Exhaustive}:
	We use this approach to find and compare all portfolios of a given size $k$.
	However, to keep the runtime under control, we limit our experiments to $k \in \{1, \dots, 5\}$.
	\item \emph{Integer Problem}:
	We use this approach to exactly determine the best portfolio for each $k \in \{1, \dots, |S|\}$.
	\item \emph{Beam Search}:
	We use this approach to search for good portfolios heuristically.
	We evaluate all $k \in \{1, \dots, |S|\}$ and also vary the beam width $w \in \{1, 2, \dots, 10, 20, \dots, 100\}$.
\end{itemize}

\subsection{Prediction Approaches}

All the solution approaches from the previous section use an oracle, the VBS, to choose a solver from the portfolio for an instance.
We also analyze the more realistic scenario of using a prediction model to recommend a solver.
To this end, we take the portfolios found by the solution approaches and train a decision tree~\cite{breiman1984classification}.
For each instance, the prediction target is the best solver out of the portfolio.
To analyze how complex the prediction model needs to be, we vary the depth of the tree from one to ten systematically. %TODO use actual number
We evaluate prediction performance in two ways:

\begin{itemize}
	\item \emph{Objective value}:
	We take the solvers recommended by the prediction model and sum up their costs, i.e., penalized runtimes or whether the instance was solved.
	The resulting objective value cannot be better than for the VBS, but also cannot be worse than for the VWS; see Section~\ref{sec:approach:problem:target}.
	\item \emph{MCC}:
	We evaluate the predictions directly with Matthews correlation coefficient~\cite{matthews1975comparison, gorodkin2004comparing}.
	This does not take into account how fast the recommended solvers actually are, but only if the fastest solver is recommended or not.
	We use MCC instead of simpler metrics like accuracy, as the class labels might be imbalanced.
	I.e., one solver might be the fastest for most of the instances, and always predicting that solver would already yield a high accuracy.
	MCC has a range of $[-1,1]$, being zero for both random guessing and always guessing the same solver.
	To test how well predictions generalize, we compute MCC in 10-fold stratified cross-validation.
\end{itemize}

\subsection{Dataset}

We obtain a dataset from the \emph{Global Benchmark Database}~\cite{iser2020collaborative}.
The dataset has $|S| = 48$ solvers and $|I| = 316$ instances.
We take the instances from the main track of the SAT Competition 2020\footnote{\url{https://satcompetition.github.io/2020/}}~\cite{balyo2020proceedings}, but discard the instances where no solver finished in time.
For predictions, we make use of 143 features to characterize instances:
138 from SATzilla~\cite{xu2008satzilla, xu2012satzilla2012} and five from a gate-recognition approach~\cite{iser2020recognition}.
We replace missing values of features with their training-set mean.
%TODO @Markus from which SATzilla version exactly?
%TODO @Markus vielleicht hast du noch eine bessere Referenz, ich habe erst mal deine Diss genommen


\paragraph{Implementation}

We implement our experimental design in Python and make our code available online\footnote{\url{https://github.com/Jakob-Bach/Small-Portfolios}}.
To create the dataset of solver runtimes, we use the package~\emph{gbd-tools}~\cite{iser2020collaborative}.
As prediction models, we use decision trees from the package \emph{scikit-learn}~\cite{scikit-learn}.
To solve the small portfolio-problem exactly, we use the package \emph{mip}~\cite{python-mip}.

\section{Evaluation}
\label{sec:evaluation}

\section{Conclusions and Future Work}
\label{sec:conclusion}


\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,references}

\end{document}
