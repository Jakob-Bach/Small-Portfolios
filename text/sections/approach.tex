\section{Approach}
\label{sec:approach}

First, we introduce the small-portfolio problem.
Next, we present multiple approaches to solve it.

\subsection{Small-Portfolio Problem}

\paragraph{Given Data}

\begin{align*}
	S &= \{s_1, \dots, s_n\} \tag*{Solvers}\\
	I &= \{i_1, \dots, i_m\} \tag*{Instances}\\
	r &: S \times I \rightarrow \mathbb{N} \cup \{\bot\} \tag*{Runtimes (censored)}\\
	T &\in \mathbb{N} \tag*{Timeout}\\
	r_T(s,i) &:= \begin{cases}
		2*T & \text{if }r(s,i) = \bot\\
		r(s,i) & \text{otherwise}
	\end{cases} \tag*{Penalized Runtimes}
\end{align*}

Let $S$ be a set of solvers and $I$ be a set of SAT instances.
Let $r(s,i)$ be the runtimes of the solvers on the instances.
If a solver encounters an error, e.g., runs out of memory, or takes longer than time $T$ on an instance, the runtime is set to $\bot$ first.
Next, we penalize these missing runtimes with the double timeout, i.e., we use a PAR2 score.
We use these penalized runtimes $r_T(s,i)$ to score the solvers.

\paragraph{Target Function}

\begin{align*}
	c_{T} &: 2^S \rightarrow \mathbb{N}\\
	c_{T}(P) &:= \begin{cases}
		|I|*2*T & \text{if }P=\emptyset\\
		\sum_{i \in I}{\min\{r_T(s,i) \mid s \in P\}} & \text{otherwise}
	\end{cases} \tag*{Portfolio Cost}
\end{align*}

The cost of a solver equals its penalized runtime, summed over all instances.
A portfolio $P \subseteq S$ is a set of solvers.
To compute the cost of a portfolio $c_{T}(P)$, we assume to have an oracle that always chooses the fastest solver for each instance.
This is the \emph{virtual-best solver} (VBS).

In reality, one may train a prediction model that recommends a solver for each instance.
Such a prediction model uses features of the SAT instances to make its recommendations.
Only if the prediction model always recommends the fastest solver out of $P$ for each instance, the portfolio has the same costs as the VBS for $P$.
Else, the costs are higher, i.e., $c_{T}(P)$ is a lower bound for the actual portfolio costs.
In the worst case, the prediction model always recommends the slowest solver out of $P$ for each instance.
This serves as an upper bound for actual portfolio costs and it the \emph{virtual worst solver} (VWS).

\paragraph{Optimization Problem}

\begin{equation}
	\label{eq:small-portfolio-problem}
	\begin{aligned}
		\min_P \quad & c_{T}(P)\\
		s.t. \quad & |P| \leq k
	\end{aligned}
   \tag{Small-Portfolio Problem}
\end{equation}

The \ref{eq:small-portfolio-problem} is to find a portfolio with minimum costs that contains at most $k$ solvers.
For each solver out of $S$, one needs to decide whether it becomes part of the portfolio $P$ or not.

\subsection{Solution Approaches}

\subsubsection{Exhaustive Search}

The simplest way to solve the \ref{eq:small-portfolio-problem} is by exhaustively searching all portfolios with at most $k$ solvers.
Due to the use of a VBS, adding a solver to the portfolio cannot increase costs.
Thus, it is sufficient to search over all portfolios with exactly $k$ solvers.
Still, there are $\binom{n}{k}$ possible portfolios to search.
This can become infeasible, given sufficiently large $n$ and $k \gg 1$ as well as $k \ll n$.

\subsubsection{Integer Programming}

The \ref{eq:small-portfolio-problem} is not linear due to the use of the $\min$ function.
However, one can make it an integer linear problem by introducing additional variables.
This allows to obtain an exact solution for the problem with a standard integer-programming solver.

\begin{equation}
	\label{eq:small-portfolio-integer-problem}
	\begin{aligned}
		\min_{x,y} \quad & \sum_{i \in I} \sum_{s \in S} r_T(s,i) * x_{s,i} \\
		s.t. \quad & \begin{aligned}
			\forall_{i\in I} \sum_{s \in S} x_{s,i} &= 1\\
			\forall_{s \in S} \sum_{i \in I} x_{s,i} &\leq |I| * y_s\\
			\sum_{s \in S} y_s &\leq k\\
			\forall_{i\in I} \forall_{s \in S}~x_{s,i} &\in \{0, 1\}\\
			\forall_{s \in S}~y_s &\in \{0,1\}
		\end{aligned}
	\end{aligned}
	\tag{Small-Portfolio Integer Problem}
\end{equation}

There are two sets of decision variables.
$x_{s,i}$ denotes whether solver $s$ is used for instance $i$.
$y_s$ denotes whether a solver is in the portfolio.
Besides the cardinality constraint on the number of solvers, there are two additional constraints.
First, exactly one solver is chosen for each instance.
Second, a solver can only be chosen for an instance if it is part of the portfolio.

\subsubsection{Beam Search}

Beam search is a greedy algorithm that finds portfolios in an iterative manner.
Algorithm~\ref{al:beam-search} describes the approach:

\begin{algorithm}[htb]
	\KwIn{Penalized runtimes $r_T(s,i)$, portfolio size $k$, beam width $w$}
	\KwOut{Portfolio $P$ with $|P|=k$}
	$\mathbb{P}^0$ $\leftarrow$ \{$\emptyset$\}\tcp*[r]{portfolios of size 0}
	\For{$i \leftarrow 1$ \KwTo $k$}{
		$\mathbb{P}^i \leftarrow \emptyset$\tcp*[r]{portfolios of size $i$}
		\ForEach{$P \in \mathbb{P}^{i-1}$}{
			\ForEach{$s \in S$}{
				\If{$s \notin P$}{
					$\mathbb{P}^i \leftarrow \mathbb{P}^i \cup \{ P \cup \{ s \} \}$\tcp*[r]{add new portfolio}
				}
			}
		}
		$\mathbb{P}^i \leftarrow$ sort($\mathbb{P}_i$, $r_T$)\tcp*[r]{sort portfolios by costs}
		$\mathbb{P}^i \leftarrow \{\mathbb{P}_j^i \in \mathbb{P}^i \mid j \leq w \}$\tcp*[r]{best $w$ portfolios of size $i$}
	}
	\Return $\underset{P \in \mathbb{P}^k}{\arg\min}~c_{T}(P)$\;
	\caption{Beam Search}
	\label{al:beam-search}
\end{algorithm}

The algorithm starts with an empty portfolio.
In each iteration, the algorithm creates all combinations of portfolios from the previous iteration and individual solvers which are not part of these portfolios.
I.e., the algorithm expands existing portfolios by adding single solvers.
Before going to the next iteration, only the $w$ portfolios with the lowest cost are retained.
The beam-width $w$ is an input parameter.
For $w=1$, only one portfolio remains at the end of each iteration.
For maximal $w$, all portfolios remain.

The algorithm is a heuristic that does not necessarily find the optimal solution to the \ref{eq:small-portfolio-problem}.
In return, its only needs to check $O(n \cdot w)$ portfolios per iteration, yielding a runtime advantage compared to exhaustive search.
